##Vari√°veis.
Se voc√™ conhece vari√°veis, ent√£o ter√° em mente um conceito semelhante em desenvolvimento. Elas s√£o locais para armazenar dados.
Algumas coisas no NVGT s√£o vari√°veis: fun√ß√µes, vari√°veis comuns, classes e muito mais.
Nessa parte, aprenderemos a como criar algumas vari√°veis simples, e como alterar seu valor.

Inteiros (ints), e inteiros sem sinal (uints).
Em NVGT, temos dois tipos principais de n√∫meros: inteiros (ints), e n√∫meros com um ponto decimal (floats).
O mais f√°cil de entender s√£o os n√∫meros inteiros, tamb√©m conhecido como (ints), aprenderemos sobre ele primeiro e depois passaremos aos n√∫meros com decimais.
Segue alguns exemplos de declara√ß√£o dos dois tipos de inteiros:
int x = 3;
x -=3; //Significa que estamos reatribuindo valor a vari√°vel.
uint y=3;
y -=3; //O n√£o!
Como voc√™ pode ver, usamos ambos os tipos de inteiros. Um √© chamado de int, mas o outro √© chamado de uint, o que significa uint? Voc√™ talvez j√° tenha adivinhado!
Falaremos sobre os uints logo. E se voc√™ n√£o deseja saber sobre bin√°rios agora, basta voc√™ saber que inteiros sem cinal sacrificam a capacidade de armazenar valores negativos, em troca de um alcanse de valores positivos de n√∫meros em dobro +1.
Primeiro vamos verificar passo a passo da nossa declara√ß√£o de int:
1. int √© o tipo de nossa vari√°vel (inteiro).
2. x e y s√£o os identificadores de nossas vari√°veis, ou seja s√£o os nomes delas.
3. O cinal de igual √© o valor de atribui√ß√£o. A primeira vez que atribu√≠mos um valor as nossas vari√°veis, significa que estamos inicializando.
4. Ap√≥s o igual, armazenamos um valor em nossa vari√°vel. Ent√£o o ponto e v√≠rgula indica que estamos finalizando nossa declara√ß√£o.
Voc√™ perceber√° que a primeira refer√™ncia de uma vari√°vel  obrigatoriamente precisa ser colocada seu tipo. Isso acontece porque √© a primeira declara√ß√£o de nossa vari√°vel, enquanto a segunda linha estamos reatribuindo um valor para ela.
Voc√™ tamb√©m pode declarar, o que chamamos de vari√°veis globais, um exemplo pr√°tico para demonstra√ß√£o:

int emails_n√£o_lidos = 20;
void main() {
    alert("Importante,", "Voc√™ tem " +emails_n√£o_lidos + "n√£o lidos!");
}

Como voc√™ pode observar, apesar da vari√°vel global n√£o ter cido declarada dentro da fun√ß√£o (ou de seu bloco), ainda podemos us√°-la. Isso acontece, porque a vari√°vel n√£o √© declarada em nenhuma fun√ß√£o, portanto, ela pode ser usada em todas as fun√ß√µes de seu software.
O altor deste manual pessoalmente, n√£o recomenda muito o uso de vari√°veis globais. Uma maneira mais pr√°tica de usar vari√°veisem muitas funcionalidades diferentes,  que ser√° falado posteriormente. A ece√ß√£o s√£o constantes (consts), que tamb√©m ser√£o abordadas em breve.
Para criar a mensagem, foi utilizado o operador de concatena√ß√£o de strings, para juntar uma string, uma vari√°vel e outra string. Este contexto, ser√° abordado com mais detalhes na ce√ß√£o strings.
Como podemos observar, dentro de uma fun√ß√£o (mas n√£o fora), vari√°veis podem ser alteradas, ou reatribu√≠das. Voc√™ deve ter notado, que mudar o valor de uma vari√°vel em rela√ß√£o a ela mesma (Como dar ao jogador algum dinheiro ou pontos) √© um efeito colateral √∫til, j√° que voc√™ pode simplesmente referenciar uma vari√°vel ao alterar seu valor assim:

inte nivel = 1;
nivel = nivel + 1;

Mas existe uma forma muito mais simples e leg√≠vel de fazer isso, que economiza tempo (e reduz poss√≠veis erros de dijita√ß√£o!).
Se voc√™ deseja mudar uma vari√°vel em rela√ß√£o a ela mesma desta forma, use o que chamamos de atribui√ß√£o composta.
√â feita a combina√ß√£o de um operador, como uma opera√ß√£o matem√°tica, ou concatena√ß√£o de strings.
Por exemplo, poder√≠amos refazer nosso c√≥digo anterior usando atribui√ß√£o composta:

int nivel = 2;
nivel += 1;

Como voc√™ pode observar, √© muito mais pr√°tico!
Segue um exemplo completo para consolidarmos o que aprendemos. Voc√™ pode copiar e colar em um script NVGT, e fazer a execu√ß√£o. Tamb√©m ser√° mostrado inclus√µes e coment√°rios novamente!

#include "speech.nvgt"
int g = 3; // Vari√°vel global.
void main(){
    /*
    Este programa demonstra n√∫meros inteiros em NVGT, declarando um (vari√°vel a) e realizando diversas opera√ß√µes matem√°ticas.
    Ap√≥s a realiza√ß√£o de cada opera√ß√£o, o valor de a ser√° falado.
    */
    int a = 0; // essa ser√° a vari√°vel que ser√° usada.
    speak("Um √© agora  " + a);
    a+=2;
    speak("Depois de adicionar 2, a agora √© " + a);
    a*=6;
    speak("Depois de multiplicar por 6, a agora √© " + a);
    a /=3;
    speak("Depois de dividir por 3, a agora √© " + a);
    //Algo novo aqui!
    a -= g;
    speak("Depois de subtrair por g, a √© agora " + a);
}

##Bin√°rios: bin√°rio 1100101 (ou 101)
Para entender inteiros com sinal e sem sinal, precisamos primeiro compreender o bin√°rio. Tamb√©m conhecido como base 2, √© um tipo de sistema baseado em 0s e 1s. √â mais conhecido por aparecer em terminais em filmes sobre hackers, mas √© essencial entender como desenvolvedor. Vamos explorar.
A vers√£o sem sinal do inteiro bin√°rio √© mais f√°cil de explicar, ent√£o iniciaremos por ela. Em termos de ordem de bytes, assumiremos big-endian, que √© provavelmente o que voc√™ estar√° usando. Little-endian √© apenas big-endian invertido, o que, como voc√™ descobrir√°, √© f√°cil de entender.
Observe uma sequ√™ncia de bits. Na base 2, podemos deduzir que o valor m√°ximo poss√≠vel √© 2 bits - 1. Os inteiros no NVGT s√£o de 32 bits, embora ele tamb√©m forne√ßa suporte aos  tipos de  int64 e uint64, se preciso.
O tipo de inteiro sem sinal (uint) no NVGT pode armazenar um valor m√°ximo de 4,294 bilh√µes. Este √© um n√∫mero relativamente grande e adequado para a maioria dos casos. O tipo de inteiro sem sinal de 64 bits pode armazenar um valor de at√© 18,446 quintilh√µes, que corresponde a mais de dois bilh√µes de vezes a popula√ß√£o mundial, e mais de 1000 vezes a quantidade de dinheiro em circula√ß√£o em toda economia, em centavos de d√≥lar.
O primeiro bit √† esquerda tem um valor correspondente de 2 elevado √† pot√™ncia de n-1, onde n √© o n√∫mero de bits.
Se o bit estiver configurado em 0, n√£o adicionamos valor ao total elevado a base 10. Se estiver configurado para 1, adicionamos seu valor.
Da esquerda para a direita, cada bit vale metade do bit anterior. Vamos dar um exemplo com 8 bits, pois √© mais f√°cil de visualizar do que 32 bits.
Observe esta sequ√™ncia de bits: 01100101
O bit mais √† esquerda nesta sequ√™ncia vale 128, que √© o valor de 2^(8-1).
Mas est√° configurado para 0, ent√£o n√£o adicionamos nada.
O pr√≥ximo bit √† direita vale 64 e est√° configurado para 1. Portanto, adicionamos 64.
O pr√≥ximo bit vale 32 e tamb√©m est√° configurado para 1, somando 32, resultando em 96.
Os pr√≥ximos dois bits valem 16 e 8, mas ambos est√£o configurados para 0, ent√£o os ignoramos.
O pr√≥ximo bit vale 4 e est√° configurado para 1. Adicionamos 4, resultando em 100.
O pr√≥ximo bit vale 2 e est√° configurado para 0, ent√£o o ignoramos. O √∫ltimo bit vale 1 e est√° configurado para 1. Adicionamos 1, resultando no total de 101.
Isso √© tudo o que voc√™ precisa saber sobre a representa√ß√£o bin√°ria sem sinal.

##Vari√°veis de pontos flutuantes (pontos decimais).
A principal diferen√ßa entre inteiros e n√∫meros de pontos flutuantes, √© que os floats podem armazenar valores com casas decimais, enquanto os ints se restrinjem exclusivamente a n√∫meros inteiros. Embora apresentem algumas desvantagens, isso tornam os n√∫meros com casas decimais, mais adequados para tarefas onde √© necess√°rio um alto n√≠vel de precis√£o, eles tamb√©m, s√£o √∫teis para trabalhar com n√∫meros imprecisos, mas extremamente grandes.
Existem dois tipos principais de n√∫meros de casas decimais (floats), em NVGT: float e double.
Float √© uma vari√°vel de 32 bits (ou precis√£o simples) e double √© uma vari√°vel de 64 bits que pode suportar o armazenamento de um n√∫mero maior de casas decimais, e expoentes mais altos.
Na maioria das vezes, voc√™ deve utilizar double, mas isso nem sempre √© necess√°rio, e de qualquer forma, muitas vezes n√£o √© uma boa op√ß√£o.
O funcionamento interno dos floats est√° al√©m do escopo deste tutorial, mas basta n√≥s sabermos que os computadores n√£o pensam em valores decimais como a gente: o conseito de decimal n√£o existe para eles.
Ao em v√©z disto, eles utilizam uma representa√ß√£o bin√°ria ppadr√£o, chamada  IEEE754.
Voc√™ n√£o pode confiar que os floats armazenem um n√∫mero perfeitamente. As vezes, o padr√£o IEEE754 n√£o tem uma representa√ß√£o exata, e o seu n√∫mero equivalente mais pr√≥ximo deve ser usado.
Para exemplificar isso, execute este script. O resultado deveria ser 1.21 mas n√£o √©.


#include "speech.nvgt"
void main(){
    double resultado = 1.1 * 1.1;
    screen_reader_speak(resultado, false); // convertendo implicitamente de double para string.
}

Como podemos observar, o valor est√° muito pr√≥ximo, mais n√£o exatamente corr√©to. At√© usamos o tipo double, com 64 bits de precis√£o, mais n√£o foi suficiente.
Existem v√°rias formas de contornar este problema, mas n√£o precisamos nos preocupar com elas por agora. Ent√£o vamos nos aprofundar em outro tipo de vari√°vel, as strings!

##Vari√°veis do tipo string.
A forma de pensar em vari√°veis do tipo string √© que elas armazenam texto, "Ol√°!", "Test" e "1" s√£o strings, (Essa √∫ltima √© confusa) mas ser√° explicado posteriormente.
Na verdade, j√° vimos vari√°veis de string anteriormente, quando est√°vamos fazendo nosso programa de Ol√° mundo, usamos duas strings para fazer nossa caixa de di√°logo, usamos como par√¢metro um t√≠tulo e um texto, passando como argumentos na fun√ß√£o alert.
Agora, conhecendo as vari√°veis e suas refer√™ncias, voc√™ pode observar que usamos "" nela, fizemos isso para indicar que ela √© uma vari√°vel do tipo string, ou seja, ela armazenar√° texto.
Se n√£o tiv√©ssemos colocado ol√° mundo entre aspas, o compilador certamente interpretaria como dois par√¢metros de fun√ß√£o, os textos entre aspas, os quais n√£o existiriam no software.
O nosso compilador NVGT, n√£o teria gostado nada disso; Certamente isso teria gerado diversos erros em nossa resposta.
No entanto, os textos nas vari√°veis do tipo string devem obrigatoriamente estar entre aspas, para permitir que o NVGT identifique, para ser mostrado ao usu√°rio.
√© como se f√¥ssemos entregar cartas: n√≥s n√£o sabemos o conte√∫do que cont√©m nela, e se soub√©ssemos, certamente nosso chefe precisaria falar com a gente! Apenas o destinat√°rio sabe quais dados tem nela.
Do mesmo modo, o NVGT colocar√° o texto entre aspas em strings, que podem ent√£o ser passadas para as funcionalidades, colocadas em vari√°veis, ou at√© mesmo serem feitas concatena√ß√µes com outras vari√°veis e strings.
Neste caso, foram atribu√≠das as vari√°veis de t√≠tulo e texto, par√¢metros da fun√ß√£o alert.
Vari√°veis do tipo string, s√£o criadas usando uma sintaxe semelhante as vari√°veis do tipo inteiro:

string nome = "rory";

Voc√™ tamb√©m pode criar uma vari√°vel com v√°rias palavras:

string mensagem="Como vai seu dia?";

Ou at√© mesmo vari√°veis com caract√©res especiais:

string mensagemDois = "Ol√°, e ‰Ω†Â•Ω üëã";

Assim como as vari√°veis do tipo inteiro, as strings tamb√©m possui opera√ß√µes que podem ser executadas nelas. De lonje o  mais comum √© as concatena√ß√µes.
Concatena√ß√£o √© o procedimento de jun√ß√£o de strings. O Cinal de +, √© usado para isso, e a atribui√ß√£o += oferece suporte.
Vejamos como funciona:

string frase = "A rapoza veloz marrom.";
mensagem += "Pula sobre o cachorro pregui√ßoso.";

Para nos  familiarizarmos com a concatena√ß√£o, ser√° apresentado um exemplo completo: Copiamos o seguinte c√≥digo em um script NVGT.

#include "speech.nvgt"
void main(){
    int a = 1;
    int b = 2;
    string c = "1";
    int d = 2;
    string resultadoUm = a + b;
    string resultadoDois = c + d;
    speak(" o resultado de a + b √©: " + resultadoUm);
    speak("O resultado de c + d √©: " + resultadoDois);
}

A sa√≠da deve ser da seguinte forma:
aO resultado de a + b √© 3.
O resultado de c + d √© 12.
Era isso que esper√°vamos?
O que est√° ocorrendo aqui √© chamada de convers√£o impl√≠cita ou autom√°tica. No desenvolvimento, converter significa fazer a conver√ß√£o de algum valor inteiro (int) para texto (string).
Quando calculamos o primeiro resultado, fazemos a soma de a+b, (1+2), e obtemos o valor 3, o que faz sentido.
Mas quando calculamos o segundo resultado, o nvgt faz a conver√ß√£o autom√°tica de d, inteiro (int), em um texto (string), tornando em 2, para que seja feita a concatena√ß√£o.
Na sequ√™ncia, ele ignora os dados internos e apenas adiciona. Ent√£o ao em v√©z de termos 1+2, n√≥s teremos "1" + "2", que s√£o dados juntos em uma string, formando o n√∫mero "12".
√â por isso que strings s√£o √∫teis: elas podem conter qualquer dado em formato testual, ent√£o, o significado destes dados podem ser interpretado por outra coisa. No nosso caso, ele √© passado para nossos leitores de tela, e podemos l√™-lo. Os sons, por si s√≥ n√£o cont√©m nenhuma informa√ß√£o sem√¢ntica.

##Vari√°veis booleanas (true e false).
Levando a um conseito muito √∫til no desenvolvimento chamado condicionais, as vari√°veis booleanas s√£o outro tipo de dados fundamentais no desenvolvimento, e geralmente est√£o presente de algum modo nas linguagens de programa√ß√£o.
Nomeadas em omenagem ao matem√°tico e l√≥gico George Boole, as vari√°veis booleanas podem armazenar apenas dois valores poss√≠veis: verdadeiro em ingl√™s (true), e fal√ßo em ingl√™s (false), ou 1 e 0, ligado ou desligado ou sim e n√£o.
Considere um interruptor de uma l√¢mpada, se ele estiver ligado, significa que √© verdadeiro caso contr√°rio, se estiver desligado, √© fal√ßo.
Eles s√£o bem poderosos, e a muitas coisas que se pode fazer com eles, mas a grande maioria deles, n√£o faz sentido sem uma condi√ß√£o estabelecida. Ainda assim, podemos exemplificar com um c√≥digo b√°sico, usando o operador l√≥gico not (!).

#include "speech.nvgt"
void main(){
    bool estado = true;
    speak("O estado √©: " + estado);
    estado = !estado;
    speak("O estado invertido, √©: " + estado);
}

Esse c√≥digo mostra como declarar um booleano: √© bastante semelhante a outras vari√°veis. Ao contr√°rio das strings, true e false n√£o precisam estar entre aspas, apesar de n√£o serem vari√°veis no sentido tradicional. Essas vari√°veis, na verdade s√£o constantes, o que significa que n√£o poderemos escrever acidentalmente seus valores; Se tentarmos, ocasionar√° em um erro.

##Constantes (consts).
Para nosso pequeno projeto, a √∫ltima coisa que veremos s√£o constantes.
Vari√°veis constantes (const), s√£o vari√°veis que nunca devem se alterar depois de serem atribu√≠das pela primeira vez. Isso deve ser realizado quando s√£o inicializadas.
Elas s√£o muito √∫teis para evitar "N√∫meros m√°gicos" em nosso c√≥digo: usar n√∫meros diretamente n√£o √© uma boa pr√°tica!
Vejamos o c√≥digo asseguir:

#include "speech.nvgt"
void main(){
    speak("Bem-vindo a loja de camping! Voc√™ precisa ter 30 d√≥lares para comprar uma cadeira de praia.");
}

Parece √≥timo, mas estamos usando esse valor em apenas uma parte de nosso c√≥digo.
Supomos que agora, que precisamos usar o  valor 30 em muitas partes: n√£o apenas para informar ao usu√°rio quanto custa comprar uma cadeira, mas tamb√©m para a pr√≥pria l√≥gica de vendas.
Isso √© muito v√°lido porque funciona, mas n√£o √© recomendado.
Considere a seguinte situa√ß√£o: A infla√ß√£o est√° tornando tudo mais caro hoje em dia, e se precisarmos alterar esse pre√ßo para 35 d√≥lares no ano seguinte?
A resposta a essa pergunta √© que seria um pesadelo! Ter√≠amos que percorrer nosso c√≥digo linha a linha, alterando a atribui√ß√£o 30 para 35. Mas poder√≠amos cometer um erro. N√£o seria muito melhor se mudarmos o valor apenas uma √∫nica vez?
√â aqui que as constantes (consts) entram em a√ß√£o!
Usando da seguinte forma, podemos reescrever nosso c√≥digo assim:

#include "speech.nvgt"
const int preco = 30;
void main() {
    speak("Bem-vindo a loja de camping! Temos uma cadeira de praia por" + preco + "d√≥lares.");
}

Muito bom! Agora podemos usar esse valor a onde queremos, e tudo o que precisamos fazer √© atualizar o valor alterando a declara√ß√£o dele.
